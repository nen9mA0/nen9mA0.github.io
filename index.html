<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>nen9mA0&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="nen9mA0&#39;s Blog">
<meta property="og:url" content="https://nen9ma0.githubio.com/index.html">
<meta property="og:site_name" content="nen9mA0&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nen9mA0&#39;s Blog">
  
    <link rel="alternate" href="/atom.xml" title="nen9mA0&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">nen9mA0&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nen9ma0.githubio.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-pthread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/pthread/" class="article-date">
  <time datetime="2018-03-18T18:42:26.972Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2018/03/19/pthread/" data-id="cjgahbb3j0000ywv0x0eib958" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Bit_Twidding_Hack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/Bit_Twidding_Hack/" class="article-date">
  <time datetime="2018-03-14T15:58:55.496Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#【翻译+整理】Bit Twiddling Hacks 位操作技巧</p>
<p>原文：<a href="http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting" target="_blank" rel="external">http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting</a></p>
<h3 id="By-Sean-Eron-Andersonseander-cs-stanford-edu"><a href="#By-Sean-Eron-Andersonseander-cs-stanford-edu" class="headerlink" title="By Sean Eron Andersonseander@cs.stanford.edu"></a>By Sean Eron Andersonseander@cs.stanford.edu</h3><p>本文中出现的代码片段是公开的（除非有特别标注）——你可以把它们用在任何地方。这些资料是由<strong>© 1997-2005 Sean Eron Anderson</strong> 搜集整理的。本文给出了代码相应的说明并希望它们对你有所帮助。但本文不对内容提供担保并且不对代码是否适用于一些特定用途提供担保。截止2005.5.5，所有的代码都被完全测试过。上千人阅读了本文。此外，卡耐基梅隆大学计算机系的院长Randal Bryant教授使用它的Uclid代码测试系统测试了几乎所有代码。我也测试了32位机上所有可能的输入。对于第一个发现代码中bug的人，我将支付10美元（通过支票或paypal）（注：译者表示我不背锅（逃）），或是支付20美元用于慈善。</p>
<p>##关于复杂度计算方法</p>
<p>当我们统计算法中共进行了几步操作时，所有C运算符被视为一步操作。所有不需要被写入内存中的中间步骤不计数。当然，这里的计算方法仅用于估算实际的机器指令数量和CPU时间。此外，假设所有的指令执行时间相同，虽然这不符合事实，但CPU的技术将朝这个方向发展。每个系统因为很多细微的差异，因此运行这些代码时的速度都各不相同，如高速缓存大小，内存带宽，指令集等的差异。最后，基准测试是判断一个算法比其他算法高效的最好方法，所以请在目标机器上测试，以确定是否使用下面技巧。</p>
<h2 id="计算整数的符号"><a href="#计算整数的符号" class="headerlink" title="计算整数的符号"></a>计算整数的符号</h2><p>####类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v;      <span class="comment">// 我们希望确定v的符号</span></span><br><span class="line"><span class="keyword">int</span> sign;   <span class="comment">// 结果存在这 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHAR_BIT 是一个字节的比特数（一般是8）</span></span><br></pre></td></tr></table></figure>
<p>####算法1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = -(v &lt; <span class="number">0</span>);  <span class="comment">// 如果 v &lt; 0 则sign=-1, 否则sign=0.</span></span><br></pre></td></tr></table></figure>
<p>####算法2</p>
<p><strong>如果希望避免指令执行时发生跳转（如IA32）</strong> （注：一般执行 v&lt;0 ,会执行test eax,edx（假设eax和edx分别存放v和0），然后jge或jb）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = -(<span class="keyword">int</span>)( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">int</span>)v) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT <span class="number">-1</span>) );</span><br></pre></td></tr></table></figure>
<p>####算法3</p>
<p><strong>如果需要更少的指令数（但可移植性差）</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = v &gt;&gt; ( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT <span class="number">-1</span> );</span><br></pre></td></tr></table></figure>
<p>最后一个表达式对于32位的整数相当于 sign = v &gt;&gt; 31。这明显比第一种要快。</p>
<h4 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h4><p><strong>如果你希望返回值是+1和-1</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = +<span class="number">1</span> | (v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="算法5"><a href="#算法5" class="headerlink" title="算法5"></a>算法5</h4><p><strong>或者你希望返回值是+1,0和-1</strong> </p>
<p>#####5.1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = (v != <span class="number">0</span>) | -(<span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">int</span>)v) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h5 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h5><p>可移植性较差但更快</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = (v != <span class="number">0</span>) | (v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>)); <span class="comment">// -1, 0, or +1</span></span><br></pre></td></tr></table></figure>
<h5 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h5><p>可移植性好且简洁（注：但跳转多）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = (v &gt; <span class="number">0</span>) - (v &lt; <span class="number">0</span>); <span class="comment">// -1, 0, or +1</span></span><br></pre></td></tr></table></figure>
<h4 id="算法6"><a href="#算法6" class="headerlink" title="算法6"></a>算法6</h4><p><strong>希望测试一个数是不是非负数，返回+1或0</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = <span class="number">1</span> ^ ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>)); <span class="comment">// if v &lt; 0 then 0, else 1</span></span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>算法3：当有符号整数右移时，当原数为负，最高位（最左一位）填充1，否则填充0。而当数字二进制位为全1时即为-1。不幸的是这个特点与架构有关（不可移植）。</p>
<p>####附注：</p>
<p>2003.3.7，<strong>Angus Duggan指出1989年的ANSI C标准没有对有符号数右移的结果给出明确的标准（ implementation-defined），所以在一些系统上这些代码可能不能用</strong> 。为了更好的可移植性，Toby Speight在2005.9.28建议加入CHAR_BIT而不是假设每个字节都是8个比特。Angus于2006.3.4推荐了上面这种更具移植性的算法。 Rohit Garg于2009.9.12推荐了判断非负数的算法。</p>
<h4 id="译者注解"><a href="#译者注解" class="headerlink" title="译者注解"></a>译者注解</h4><p>算法1不解释，v&lt;0返回的是0或1</p>
<p>算法2和算法3原理类似。注意，算法有个前提就是C编译器对于有符号数位移操作采取<strong>算术右移</strong> 而非 <strong>逻辑右移</strong> 对于无符号数相反（附注中说明了这个行为其实取决于编译器）。对于算法2，先将v转换为无符号，之后位移。因为为无符号，因此高位补0，移位后v中只保留了原数的最高位，因为int型为补码存储，最高位为符号位，若原数小于0，则结果为000…001，反之为000…000，因此sign返回-1或0。</p>
<p>算法3因为v为有符号，因此如果符号位为1，右移高位补1，结果为111…111，即补码的-1，反之为000…000</p>
<p>算法4为算法3的结果 或+1，对于-1，-1 | +1 = 111…111 | 000…001 = 111…111 = -1，对于0，为+1</p>
<p>算法5.1和5.2与4原理相同，当v!=0时进行或运算的就是+1，否则为0.</p>
<p>算法5.3，若v&gt;0，则 (v&gt;0)-(v&lt;0) = 1-0=1  若v&lt;0为-1，若v=0为0</p>
<p>算法6改或为异或，当后一个式子为0时，即v&gt;=0时结果为1；后一个式子为1时（注意这里为逻辑右移）结果0。</p>
<h2 id="判断两数符号是否相反"><a href="#判断两数符号是否相反" class="headerlink" title="判断两数符号是否相反"></a>判断两数符号是否相反</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;               <span class="comment">// 待比较的数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// 如果x和y符号相反则为真</span></span><br></pre></td></tr></table></figure>
<h4 id="附注："><a href="#附注：" class="headerlink" title="附注："></a>附注：</h4><p>Manfred Weis于2009.11.26建议加入</p>
<h4 id="译者注解-1"><a href="#译者注解-1" class="headerlink" title="译者注解"></a>译者注解</h4><p>若x和y符号相反，即符号位不同。此时进行位异或运算，符号位为1，因此运算结果为一负数。</p>
<h2 id="不使用跳转计算一个整数的绝对值"><a href="#不使用跳转计算一个整数的绝对值" class="headerlink" title="不使用跳转计算一个整数的绝对值"></a>不使用跳转计算一个整数的绝对值</h2><p>####定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v;           <span class="comment">// 计算v的绝对值</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> r;  <span class="comment">// 结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mask = v &gt;&gt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>;<span class="comment">//定义一个掩码，值为v算术右移至仅保留最高位</span></span><br></pre></td></tr></table></figure>
<p>####算法1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (v + mask) ^ mask;</span><br></pre></td></tr></table></figure></p>
<p>####算法2 （已被申请专利）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (v ^ mask) - mask;</span><br></pre></td></tr></table></figure></p>
<p>####解释：</p>
<p>一些CPU没有取整数绝对值的指令（或者编译器不支持）。在那些跳转开销较大的机器上，上面的程序要比<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (v &lt; <span class="number">0</span>) ? -(<span class="keyword">unsigned</span>)v : v;</span><br></pre></td></tr></table></figure></p>
<p>来的快，即使两者指令数相同。</p>
<h4 id="附注：-1"><a href="#附注：-1" class="headerlink" title="附注："></a>附注：</h4><p>2003.3.7，<strong>Angus Duggan指出1989年的ANSI C标准没有对有符号数右移的结果给出明确的标准（ implementation-defined），所以在一些系统上这些代码可能不能用</strong> （好像很熟悉？是的跟第一个程序的附注是同样的）。<strong>我曾阅读ANSI C，里面并未要求整数必须用补码表示，所以程序也有可能因此不能用</strong> 。（在一些很古老的机子里用的可能是反码）。2004.3.14，Keith H. Duggar向我发送了上面提到的专利算法。这是我最早提出的算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=(+<span class="number">1</span>|(v&gt;&gt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*CHAR_BIT<span class="number">-1</span>)))*v</span><br></pre></td></tr></table></figure></p>
<p>的升级版，因为少用了一个乘法。不幸的是，这个算法于2000.6.6被 Vladimir Yu Volkonsky申请了专利并用到了Sun系统上。2006.8.13，Yuriy Kaminskiy告诉我专利可能是无效的，因为在申请专利之前这个方法就已经被公开发表，比如1996年11月9日Agner Fog的《How to Optimize for the Pentium Processor》（如何为奔腾处理器做优化）。Yuriy还提到这个文档1997年的时候被翻译成了俄文，Vladimir可能读过了。此外，网站时光倒流机器（The Internet Archive）也存在到这里的旧链接。2007.1.30，Peter Kankowski 给作者分享了一个版本的求绝对值，灵感来源于Microsoft’s Visual C++编译器的输出。在这里作为最终解决方案。2007.12.6 Hai Jin抱怨运算的结果是有符号的，所以当计算负数中的最大值时，得到的结果还是负数。2008.4.15 Andrew Shapira指出上述三元运算符的方法可能会出现溢出，因为缺少(unsigned)的类型说明；为了最佳的可移植性，他建议写作： (v &lt; 0) ? (1 + ((unsigned)(-1-v))) : (unsigned)v。2008.7.9 Vincent Lefèvre说服作者删除了它（上述的式）而采用了原来的式（解释中提到的那个式子）。因为即使在非二进制补码的机器上，根据ISO C99规范， -(unsigned)v也是正确的。-(unsigned)v运算时，先通过加2^N转换为无符号数，得到v的补码表示，我们称为U。所以U=v+2^N，又因为</p>
<p>-v=2^N - (v+2^N) = 2^N - U = 0 - U = -U ，所以 -(unsigned)v = -U = -v</p>
<h4 id="译者注解-2"><a href="#译者注解-2" class="headerlink" title="译者注解"></a>译者注解</h4><p>若v&lt;0，则mask=111…111，算法1=(v-1)^-1 =-v   算法2=(v^-1) +1 = -v</p>
<p>算法1因为v-1除符号位外其余各位都与v相反，又 ^-1相当于按位取反，因此运算完毕后符号位清零，其余各位保留-v的原码。</p>
<p>算法2更直接，就是平时常用的补码和原码转换。</p>
<p>若v&gt;=0，则mask=000…000，算法1= (v+0) ^0 =v    算法2= (v^0) - 0=v</p>
<h2 id="计算两个整数的最大值和最小值（无跳转）"><a href="#计算两个整数的最大值和最小值（无跳转）" class="headerlink" title="计算两个整数的最大值和最小值（无跳转）"></a>计算两个整数的最大值和最小值（无跳转）</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;  <span class="comment">// 两个整数</span></span><br><span class="line"><span class="keyword">int</span> y;   </span><br><span class="line"><span class="keyword">int</span> r;  <span class="comment">// 结果</span></span><br></pre></td></tr></table></figure>
<h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = y ^ ((x ^ y) &amp; -(x &lt; y)); <span class="comment">// min(x, y)</span></span><br><span class="line">r = x ^ ((x ^ y) &amp; -(x &lt; y)); <span class="comment">// max(x, y)</span></span><br></pre></td></tr></table></figure>
<p>在极少数的机器上，跳转开销很大且没有条件转移指令，上述代码可能比有跳转的实现要快<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (x &lt; y) ? x : y</span><br></pre></td></tr></table></figure></p>
<p>即使它多使用了两个指令（但一般跳转实现更快）。</p>
<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>因为若 x&lt;y，-(x&lt;y)为-1（补码为111…111），所以相当于 r= y^( (x^y) &amp; ~0) = y^x^y =x</p>
<p>若x&gt;=y，-(x&lt;y)为0，所以相当于 r=y^( (x^y) &amp; 0) = y^0=y</p>
<p>max同理</p>
<p>####算法2</p>
<p>如果能保证 INT_MIN &lt;= x-y &lt;= INT_MAX，则可以使用下面的代码，因为只用算一次 x-y所以更快</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = y + ((x - y) &amp; ((x - y) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>))); <span class="comment">// min(x, y)</span></span><br><span class="line">r = x - ((x - y) &amp; ((x - y) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * CHAR_BIT - <span class="number">1</span>))); <span class="comment">// max(x, y)</span></span><br></pre></td></tr></table></figure>
<h4 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h4><p>1989 ANSI C没有明确右移行为，所以代码可能无法移植。如果因为溢出抛出异常</p>
<p>Ref：</p>
<p><a href="https://site.douban.com/196781/" target="_blank" rel="external">https://site.douban.com/196781/</a>     God-Mode 豆瓣小站，在该站的奇技淫巧（emmm。。。）条目下有本文大概半篇多的翻译。本人的很多翻译也参考了站内大神的翻译。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2018/03/14/Bit_Twidding_Hack/" data-id="cjer9tqqn00033ov0nwx8l9tn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-emmmm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/emmmm/" class="article-date">
  <time datetime="2018-03-14T15:54:33.752Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="emmmm"><a href="#emmmm" class="headerlink" title="emmmm"></a>emmmm</h1><p>咕了4个月</p>
<p>终于找到友链为什么炸了</p>
<p>因为。。。我友链文件没按.yml的格式写</p>
<p>: (</p>
<p>其实是因为懒癌晚期</p>
<p>到今天才想着重新搞一下</p>
<p>把之前翻译的z3py发上来</p>
<p>然后开个坑</p>
<p>美滋滋（并不</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2018/03/14/emmmm/" data-id="cjer9tqq700013ov0qmde53io" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-z3py" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/z3py/" class="article-date">
  <time datetime="2018-03-14T15:51:47.773Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Z3-API-in-Python"><a href="#Z3-API-in-Python" class="headerlink" title="Z3 API in Python"></a>Z3 API in Python</h1><p>原文地址：<a href="http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm" target="_blank" rel="external">http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm</a></p>
<p>Z3是微软研究院开发的一个高效的定理证明器。Z3可以被用于很多场景，例如：软件/硬件测试、约束求解、混合系统分析、安全、生物（药物设计）和几何问题。</p>
<p>这个教程展示了Z3Py的主要功能：python里的Z3 API。阅读此教程不需要Python基础。但学习Python很有用，同时也有很多的Python免费教程供我们学习（<a href="https://docs.python.org/3/tutorial/）" target="_blank" rel="external">https://docs.python.org/3/tutorial/）</a></p>
<p>Z3同样包含了C、.net和OCaml的API。Z3Py的源代码可以在Z3发行版中看到，你可以按照你的需求进行修改。源代码也展示了如何使用Z3 4.0的新功能。其他酷炫的Z3前端有ScalaZ3和SBV。</p>
<p>###入门</p>
<p>让我们从下面这个例子开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>函数 <strong>Int(‘x’)</strong> 定义了一个叫x的Z3整型变量， <strong>solve</strong> 函数求解这一约束系统。上面的例子用到了两个变量 <strong>x</strong> 和 <strong>y</strong> ，还有三个约束。Z3Py和Python一样使用 <strong>=</strong> 赋值。运算符 <strong>&lt;,&lt;=,&gt;,&gt;=,==,!=</strong> 用于比较。在上述例子中，表达式 <strong>x+2*y==7</strong> 是一个Z3约束。Z3可以求解并处理该等式。</p>
<p>下一个例子展示了如何用Z3公式/表达式 <strong>simplifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x &lt; y + x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>默认情况下，Z3Py（Web版）使用数学记号显示表达式。通常∧是逻辑与，∨是逻辑或。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_option(html_mode=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>使所有公式和表达式以Z3Py的记号显示。这也是Z3发行版的默认模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span></span><br><span class="line">set_option(html_mode=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span>py</span><br></pre></td></tr></table></figure>
<p>Z3提供拆分表达式的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num args: "</span>, n.num_args()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"children: "</span>, n.children()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1st child:"</span>, n.arg(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"2nd child:"</span>, n.arg(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"operator: "</span>, n.decl()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"op name:  "</span>, n.decl().name()</span><br></pre></td></tr></table></figure>
<p>Z3支持所有基础数学运算。Z3Py使用与Python相同的运算优先级。如Python中，**是乘幂。Z3可以求解非线性多项式约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> &gt; <span class="number">3</span>, x**<span class="number">3</span> + y &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Real(‘x’)</strong> 建立一个实变量x。Z3Py可以表示任意大的整数，有理数（如上面例子所示），代数数。代数数是指任何整系数多项式的复根。Z3内部精确的表示了每个数。无理数被显示为十进制使我们较容易读出结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">set_option(precision=<span class="number">30</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving, and displaying result with 30 decimal places"</span></span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>set_option</strong> 指令用于设置Z3环境。它被用于设置全局属性，如结果如何显示等。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_option(precision=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>设置显示结果时显示的十进制数有几位。数值 <strong>1.2599210498?</strong> 中的 <strong>?</strong> 标记表示输出是被截断的。</p>
<p>下面的例子展示了一个常见的错误。表达式 <strong>3/2</strong> 是个Python数值但不是Z3中的有理数。这个例子也展示了创建有理数的不同方法。函数 <strong>Q(num,den)</strong> 创建一个Z3有理数，其中num是分子，den是分母。<strong>RealVal(1)</strong> 创建一个表示数值1的Z3实数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> RealVal(<span class="number">1</span>)/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> Q(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> x + Q(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="string">"1/3"</span></span><br><span class="line"><span class="keyword">print</span> x + <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>有理数也可以以十进制显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">set_option(rational_to_decimal=<span class="keyword">True</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">set_option(precision=<span class="number">30</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一个约束系统不一定有解，在这种情况下，我们称系统无法满足（unsatisfiable）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(x &gt; <span class="number">4</span>, x &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>跟Python一样，单行注释使用 <strong>#</strong> ，但Z3Py不支持多行注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line">x = Real(<span class="string">'x'</span>) <span class="comment"># comment: creating x</span></span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + <span class="number">2</span>*x + <span class="number">2</span>  <span class="comment"># comment: printing polynomial</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>Z3支持的逻辑运算符：And,Or,Not,Implies(蕴含),If(if-then-else)。双蕴含用 <strong>==</strong> 表示。下面的例子展示了如何求解一个布尔约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line">r = Bool(<span class="string">'r'</span>)</span><br><span class="line">solve(Implies(p, q), r == Not(q), Or(Not(p), r))</span><br></pre></td></tr></table></figure>
<p>Python中的布尔常量 <strong>True</strong> 和 <strong>False</strong> 可以用于Z3表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line"><span class="keyword">print</span> And(p, q, <span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, q, <span class="keyword">True</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, <span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>
<p>下面的例子同时使用了多项式和布尔表达式约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(Or(x &lt; <span class="number">5</span>, x &gt; <span class="number">10</span>), Or(p, x**<span class="number">2</span> == <span class="number">2</span>), Not(p))</span><br></pre></td></tr></table></figure>
<h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>Z3提供了不同的求解器。上述例子中使用的命令 <strong>solve</strong> 调用了Z3求解器的API。这些调用可以在Z3目录下的 <strong>z3.py</strong> 中找到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">s.add(x &gt; <span class="number">10</span>, y == x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving constraints in the solver s ..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Create a new scope..."</span></span><br><span class="line">s.push()</span><br><span class="line">s.add(y &lt; <span class="number">11</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving updated set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Restoring state..."</span></span><br><span class="line">s.pop()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving restored set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure>
<p><strong>Solver()</strong> 命令定义了一个通用的求解器。所有约束式可以通过 <strong>add</strong> 方法添加。我们称约束式在求解器中 <strong>被声明</strong>。<strong>check()</strong> 方法求解所有已添加进求解器的约束式。如果可以求得解，该方法返回 <strong>sat</strong> 。如果不能求出解则返回 <strong>unsat</strong> 。也有可能出现声明的约束式不成立的情况，这时求解器返回 <strong>unknown</strong> 。</p>
<p>在一些应用下，我们希望求解一些相似的问题，这些问题有部分同样的约束式。我们可以使用 <strong>push</strong> 和 <strong>pop</strong> 命令。在Z3中，每个求解器维护一个保存声明的栈， <strong>push</strong> 命令保存当前栈空间大小，并创建一个空间，压入新的声明。 <strong>pop</strong> 命令删除上一个 <strong>push</strong> 命令压入的所有声明。<strong>check</strong> 方法计算求解器栈内的所有约束式。</p>
<p>下面的展示了一个Z3不能求解的例子。这种情况下求解器返回<strong>unknown</strong> 。注意Z3可以求解非线性多项式约束，但 2**x 不是多项式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure>
<p>下面的例子展示了如何将声明的约束式传入求解器，以及如何通过<strong>check</strong> 方法获取求解器状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, Or(x + y &gt; <span class="number">3</span>, x - y &lt; <span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"asserted constraints..."</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s.assertions():</span><br><span class="line">    <span class="keyword">print</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"statistics for the last check method..."</span></span><br><span class="line"><span class="keyword">print</span> s.statistics()</span><br><span class="line"><span class="comment"># Traversing statistics</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s.statistics():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s : %s"</span> % (k, v)</span><br></pre></td></tr></table></figure>
<p>当求解器找到解时， <strong>check</strong> 方法返回 <strong>sat</strong> 。我们称Z3求出满足约束式的解。我们称这个解为所声明的约束式的一个模型。一个模型是指一种解释，能使所有约束式满足。下面的例子展示了查看模型的基本方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = Reals(<span class="string">'x y z'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, x + y &gt; <span class="number">3</span>, z - x &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"x = %s"</span> % m[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，函数 <strong>Reals(‘x y z’)</strong> 创建了变量 x，y和z。这是下述写法的简写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">z = Real(<span class="string">'z'</span>)</span><br></pre></td></tr></table></figure>
<p>表达式 <strong>m[x]</strong> 模型m中的返回x的值。表达式 <strong>“%s = %s” % (d.name(), m[d])</strong> 返回一个字符串，其中第一个%s被d对象的name属性替换，第二个%s被<strong>m[d]</strong> 的值替换（注：Python语法）。Z3Py会自动地将Z3对象的值全部转换为文本。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>Z3支持实型和整型变量。在单个问题中两种变量可以混合使用。与大多数编程语言一样，当我们需要时，Z3Py会自动地将整型表达式强制转换为实型。下面的例子展示了各种声明整型和实型变量的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">a, b, c = Reals(<span class="string">'a b c'</span>)</span><br><span class="line">s, r = Ints(<span class="string">'s r'</span>)</span><br><span class="line"><span class="keyword">print</span> x + y + <span class="number">1</span> + (a + s)</span><br><span class="line"><span class="keyword">print</span> ToReal(y) + c</span><br></pre></td></tr></table></figure>
<p>函数<strong>ToReal</strong> 将一个整型表达式转换为实型。</p>
<p>Z3Py支持所有的基本的运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = Ints(<span class="string">'a b c'</span>)</span><br><span class="line">d, e = Reals(<span class="string">'d e'</span>)</span><br><span class="line">solve(a &gt; b + <span class="number">2</span>,</span><br><span class="line">      a == <span class="number">2</span>*c + <span class="number">10</span>,</span><br><span class="line">      c + b &lt;= <span class="number">1000</span>,</span><br><span class="line">      d &gt;= e)</span><br></pre></td></tr></table></figure>
<p>函数<strong>simplify</strong> 提供了一些方法，可以对Z3表达式进行简单变换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment"># Put expression in sum-of-monomials form</span></span><br><span class="line">t = simplify((x + y)**<span class="number">3</span>, som=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br><span class="line"><span class="comment"># Use power operator</span></span><br><span class="line">t = simplify(t, mul_to_power=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br></pre></td></tr></table></figure>
<p><strong>help_simplify</strong> 函数打印<strong>simplify</strong> 函数所有可用的参数。Z3Py允许用户以两种方式写入这些参数。Z3内部的参数名以<strong>:</strong> 开头并以<strong>-</strong> 隔开各个单词。这些参数可以被Z3Py使用。Z3Py也提供了一些符合Python变量命名规则的名字，在这里<strong>:</strong> 被移除，<strong>-</strong> 被<strong>_</strong> 取代。下面的例子展示了怎样使用以这两种方式调用函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment"># Using Z3 native option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, <span class="string">':arith-lhs'</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Using Z3Py option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, arith_lhs=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nAll available options:"</span></span><br><span class="line">help_simplify()</span><br></pre></td></tr></table></figure>
<p>Z3Py可以支持任意大的数字。下面的例子展示了使用大数，有理数和无理数进行基本运算。无理数中，Z3Py只支持代数数。代数数已经足够表示多项式约束的解了。Z3Py总是以十进制显示无理数，因为这方便阅读。可以使用 <strong>sexpr()</strong> 方法提取Z3内部的表达式，它能以S-表达式（s-expression）的形式显示Z3内部的数学表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line">solve(x + <span class="number">10000000000000000000000</span> == y, y &gt; <span class="number">20000000000000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)).sexpr()</span><br><span class="line"><span class="comment"># The sexpr() method is available for any Z3 expression</span></span><br><span class="line"><span class="keyword">print</span> (x + Sqrt(y) * <span class="number">2</span>).sexpr()</span><br></pre></td></tr></table></figure>
<h3 id="硬件相关的运算"><a href="#硬件相关的运算" class="headerlink" title="硬件相关的运算"></a>硬件相关的运算</h3><p>（注：此处为意译）</p>
<p>现代CPU和主流的编程语言使用基于固定大小的位向量的进行运算（注：如32位CPU采用基于位宽为32的数据进行运算）。在Z3Py中可以以位向量的方式进行这样的运算。位向量使我们可以看到有符号与无符号数的精确的补码表示。</p>
<p>下面的例子展示了如何创建位向量变量和常数。函数 <strong>BitVec(‘x’,16)</strong> 在Z3中创建了一个16位，名字为 <strong>x</strong> 的变量。为了方便使用，整数常量可以用于初始化位向量。函数 <strong>BitVecVal(10,32)</strong> 创建了一个32位的，值为10 的位向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = BitVec(<span class="string">'x'</span>, <span class="number">16</span>)</span><br><span class="line">y = BitVec(<span class="string">'y'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="number">2</span></span><br><span class="line"><span class="comment"># Internal representation</span></span><br><span class="line"><span class="keyword">print</span> (x + <span class="number">2</span>).sexpr()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -1 is equal to 65535 for 16-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(x + y - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating bit-vector constants</span></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">16</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br><span class="line"></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">32</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment"># -1 is not equal to 65535 for 32-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br></pre></td></tr></table></figure>
<p>其他编程语言，如C，C++，C#，Java的有符号与无符号数的各种运算对应的实际操作没有什么区别。但在Z3中，有符号数与无符号数使用不同的运算操作。 <strong>&lt;,&lt;=,&gt;,&gt;=,/,%,&gt;&gt;</strong> 运算对应有符号数，相对应的无符号数运算符为 <strong>ULT,ULE,UGT,UGE,UDiv,URem,LShR</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x + y == <span class="number">2</span>, x &gt; <span class="number">0</span>, y &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bit-wise operators</span></span><br><span class="line"><span class="comment"># &amp; bit-wise and</span></span><br><span class="line"><span class="comment"># | bit-wise or</span></span><br><span class="line"><span class="comment"># ~ bit-wise not</span></span><br><span class="line">solve(x &amp; y == ~y)</span><br><span class="line"></span><br><span class="line">solve(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># using unsigned version of &lt; </span></span><br><span class="line">solve(ULT(x, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>运算符 <strong>&gt;&gt;</strong> 是算术右移， <strong>&lt;&lt;</strong> 是算术左移。逻辑右移是 <strong>LShR</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x &gt;&gt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>不像其他编程语言，函数可以抛出异常或者无法返回。Z3的函数是完全定义的，即，函数是被所有输入的值所定义的，其中输入的值可以是一个函数，如划分函数。Z3是基于一阶逻辑的。</p>
<p>当我们给出约束式，如 <strong>x+y&gt;3</strong> 时，我们称 <strong>x</strong> 和 <strong>y</strong> 是变量。在很多书中，<strong>x</strong> 和 <strong>y</strong> 称为未定义常量。即，它们可以被赋值为任何满足约束式 <strong>x+y&gt;3</strong> 的值。</p>
<p>准确地说，一阶逻辑中的函数和符号常量是未定义的。这与很多其他理论中的函数相反，如算法中的函数 <strong>+</strong> 拥有标准的定义（将两数相加）。未定义函数和常量可以提供最大限度的灵活性：只要符合约束式，允许对函数和常量做出任何定义。（注：此段感觉翻译有误）</p>
<p>为了解释未定义的函数和常量的含义，我们定义了两个整数常量x和y。然后声明一个未进行定义的函数，这个函数有一个整型参数且返回值为一个整型。这个例子展示了我们可以使嵌套调用两次的f(x)等于x，即f(f(x)) == x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">f = Function(<span class="string">'f'</span>, IntSort(), IntSort())</span><br><span class="line">solve(f(f(x)) == x, f(x) == y, x != y)</span><br></pre></td></tr></table></figure>
<p>返回的结果为：f函数的定义是：f(0)=1 f(1)=0 f(a)=1 当a≠0,1</p>
<p>（注：这段因为涉及到一阶逻辑的知识翻了好久还是一头雾水，不过看了下代码，这段大概的意思应该就是，Z3的输入可以是一个未定义具体内容的函数，它可以通过与该函数相关的一些约束式来求出符合要求的函数模型）</p>
<p>在Z3中，我们也可以计算在一系列约束式下的一些表达式的值。下面的例子说明了如何使用 <strong>evaluate</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">f = Function(<span class="string">'f'</span>, IntSort(), IntSort())</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(f(f(x)) == x, f(x) == y, x != y)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"f(f(x)) ="</span>, m.evaluate(f(f(x)))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"f(x)    ="</span>, m.evaluate(f(x))</span><br></pre></td></tr></table></figure>
<p>###可满足性和有效性</p>
<p>当一个约束式/公式 F的值在任何有效取值下始终为真，称该公式为普遍有效公式（即恒真公式）。当约束式在一些取值下为真则称公式为可满足的。验证有效性时，即需要找出命题为永真的证明。验证可满足性则是求出一个满足式子的集合。考虑一个包含 <strong>a</strong> 和 <strong>b</strong> 的公式 <strong>F</strong> 。<strong>F</strong> 是否普遍有效即是否在 <strong>a</strong> 和 <strong>b</strong> 的所有取值下<strong>F</strong> 都为真。如果<strong>F</strong> 是有效的，则<strong>Not(F)</strong> 为永假的，即<strong>Not(F)</strong> 在任何取值下都不为真，即，<strong>Not(F)</strong> 是不可满足的。所以公式<strong>F</strong> 在<strong>Not(F)</strong> 不可满足时为永真的。 同样，当且仅当 <strong>Not(F)</strong> 不为永真时，<strong>F</strong> 是可满足的。下面的例子证明了<strong>德摩根定理</strong> 。</p>
<p>下面的例子定义了一个Z3Py函数，它接收了一个公式作为参数。这个函数创建一个Z3求解器，并添加了传入参数的公式的<strong>非</strong> ，检查这个公式的非是否是不可满足的。下述的函数是Z3Py的命令<strong>prove</strong> 的简化版。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p, q = Bools(<span class="string">'p q'</span>)</span><br><span class="line">demorgan = And(p, q) == Not(Or(Not(p), Not(q)))</span><br><span class="line"><span class="keyword">print</span> demorgan</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prove</span><span class="params">(f)</span>:</span></span><br><span class="line">    s = Solver()</span><br><span class="line">    s.add(Not(f))</span><br><span class="line">    <span class="keyword">if</span> s.check() == unsat:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"proved"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"failed to prove"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Proving demorgan..."</span></span><br><span class="line">prove(demorgan)</span><br></pre></td></tr></table></figure>
<h3 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h3><p>Python支持列表解析式。列表解析式为创建列表提供了一个简便的方法。它们可以用于创建Z3表达式。下面的例子展示了如何在Z3Py中使用过列表解析式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> Create list [<span class="number">1</span>, ..., <span class="number">5</span>] </span><br><span class="line"><span class="keyword">print</span> [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create two lists containg 5 integer variables</span></span><br><span class="line">X = [ Int(<span class="string">'x%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line">Y = [ Int(<span class="string">'y%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a list containing X[i]+Y[i]</span></span><br><span class="line">X_plus_Y = [ X[i] + Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_plus_Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a list containing X[i] &gt; Y[i]</span></span><br><span class="line">X_gt_Y = [ X[i] &gt; Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_gt_Y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> And(X_gt_Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a 3x3 "matrix" (list of lists) of integer variables</span></span><br><span class="line">X = [ [ Int(<span class="string">"x_%s_%s"</span> % (i+<span class="number">1</span>, j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>) ] </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>) ]</span><br><span class="line">pp(X)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，表达式 <strong>“x%s” %i</strong> 返回一个由i的值替换%s的字符串。</p>
<p>命令<strong>pp</strong> 与<strong>print</strong> 类似，但它使用Z3用于格式化元组和列表的格式化字符串，而不是Python的。</p>
<p>Z3Py也提供创建布尔、整型和实型向量的函数，这些函数可以在列表解析式中被执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = IntVector(<span class="string">'x'</span>, <span class="number">5</span>)</span><br><span class="line">Y = RealVector(<span class="string">'y'</span>, <span class="number">5</span>)</span><br><span class="line">P = BoolVector(<span class="string">'p'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line"><span class="keyword">print</span> Y</span><br><span class="line"><span class="keyword">print</span> P</span><br><span class="line"><span class="keyword">print</span> [ y**<span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> Y ]</span><br><span class="line"><span class="keyword">print</span> Sum([ y**<span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> Y ])</span><br></pre></td></tr></table></figure>
<p>（注：下面内容为Z3在一些领域应用的示例）</p>
<p>###运动方程</p>
<p>在高中中，我们学习过运动方程。这些等式描述了位移、时间、加速度、初速度和末速度的关系。在Z3Py中可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span></span><br><span class="line">v_f == v_i + a*t</span><br></pre></td></tr></table></figure>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>Ima Hurryin以30m/s的速度靠近红绿灯。此时灯变黄，Ima踩下刹车。如果Ima的加速度为-8.00m/s^2，请计算车辆在减速过程中的位移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d, a, t, v_i, v_f = Reals(<span class="string">'d a t v__i v__f'</span>)</span><br><span class="line"></span><br><span class="line">equations = [</span><br><span class="line">   d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span>,</span><br><span class="line">   v_f == v_i + a*t,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Kinematic equations:"</span></span><br><span class="line"><span class="keyword">print</span> equations</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given v_i, v_f and a, find d</span></span><br><span class="line">problem = [</span><br><span class="line">    v_i == <span class="number">30</span>,</span><br><span class="line">    v_f == <span class="number">0</span>,</span><br><span class="line">    a   == <span class="number">-8</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Problem:"</span></span><br><span class="line"><span class="keyword">print</span> problem </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solution:"</span></span><br><span class="line">solve(equations + problem)</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>Ben Rushin在等红绿灯。当灯变绿时，Ben以6.00m/s^2的加速度加速4.10秒。请计算这段时间Ben的位移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d, a, t, v_i, v_f = Reals(<span class="string">'d a t v__i v__f'</span>)</span><br><span class="line"></span><br><span class="line">equations = [</span><br><span class="line">   d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span>,</span><br><span class="line">   v_f == v_i + a*t,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given v_i, t and a, find d</span></span><br><span class="line">problem = [</span><br><span class="line">    v_i == <span class="number">0</span>,</span><br><span class="line">    t   == <span class="number">4.10</span>,</span><br><span class="line">    a   == <span class="number">6</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">solve(equations + problem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display rationals in decimal notation</span></span><br><span class="line">set_option(rational_to_decimal=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">solve(equations + problem)</span><br></pre></td></tr></table></figure>
<p>###位运算技巧</p>
<p>一些底层的位运算技巧在C程序员中很流行。我们试着用Z3实现其中一些技巧。</p>
<h4 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h4><p>这个技巧常用于C程序（包括Z3源码）中测试一个整数是否是2的幂。我们可以用Z3证明这个算法的正确性。此处即证明 <strong>x != 0 &amp;&amp; !(x &amp; (x - 1))</strong> 为真，当且仅当<strong>x</strong> 为2的幂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x      = BitVec(<span class="string">'x'</span>, <span class="number">32</span>)</span><br><span class="line">powers = [ <span class="number">2</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>) ]</span><br><span class="line">fast   = And(x != <span class="number">0</span>, x &amp; (x - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">slow   = Or([ x == p <span class="keyword">for</span> p <span class="keyword">in</span> powers ])</span><br><span class="line"><span class="keyword">print</span> fast</span><br><span class="line">prove(fast == slow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"trying to prove buggy version..."</span></span><br><span class="line">fast   = x &amp; (x - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">prove(fast == slow)</span><br></pre></td></tr></table></figure>
<p>####相反数</p>
<p>下面的技巧用于测试两个数是否互为相反数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x      = BitVec(<span class="string">'x'</span>, <span class="number">32</span>)</span><br><span class="line">y      = BitVec(<span class="string">'y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Claim: (x ^ y) &lt; 0 iff x and y have opposite signs</span></span><br><span class="line">trick  = (x ^ y) &lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Naive way to check if x and y have opposite signs</span></span><br><span class="line">opposite = Or(And(x &lt; <span class="number">0</span>, y &gt;= <span class="number">0</span>),</span><br><span class="line">              And(x &gt;= <span class="number">0</span>, y &lt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">prove(trick == opposite)</span><br></pre></td></tr></table></figure>
<h3 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h3><h4 id="猫狗和老鼠"><a href="#猫狗和老鼠" class="headerlink" title="猫狗和老鼠"></a>猫狗和老鼠</h4><p>我们花费100美元要购买100只动物。每只狗15美元，猫1美元，老鼠25美分。且必须每种至少买一只，求购买方案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create 3 integer variables</span></span><br><span class="line">dog, cat, mouse = Ints(<span class="string">'dog cat mouse'</span>)</span><br><span class="line">solve(dog &gt;= <span class="number">1</span>,   <span class="comment"># at least one dog</span></span><br><span class="line">      cat &gt;= <span class="number">1</span>,   <span class="comment"># at least one cat</span></span><br><span class="line">      mouse &gt;= <span class="number">1</span>, <span class="comment"># at least one mouse</span></span><br><span class="line">      <span class="comment"># we want to buy 100 animals</span></span><br><span class="line">      dog + cat + mouse == <span class="number">100</span>,  </span><br><span class="line">      <span class="comment"># We have 100 dollars (10000 cents):</span></span><br><span class="line">      <span class="comment">#   dogs cost 15 dollars (1500 cents), </span></span><br><span class="line">      <span class="comment">#   cats cost 1 dollar (100 cents), and </span></span><br><span class="line">      <span class="comment">#   mice cost 25 cents </span></span><br><span class="line">      <span class="number">1500</span> * dog + <span class="number">100</span> * cat + <span class="number">25</span> * mouse == <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h4><p>下面的例子展示了如何用Z3求解数独问题。其中<strong>instance</strong> 定义了数独矩阵。这个例子大量使用了Python中的列表解析式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 9x9 matrix of integer variables</span><br><span class="line">X = [ [ Int(&quot;x_%s_%s&quot; % (i+1, j+1)) for j in range(9) ] </span><br><span class="line">      for i in range(9) ]</span><br><span class="line"></span><br><span class="line"># each cell contains a value in &#123;1, ..., 9&#125;</span><br><span class="line">cells_c  = [ And(1 &lt;= X[i][j], X[i][j] &lt;= 9) </span><br><span class="line">             for i in range(9) for j in range(9) ]</span><br><span class="line"></span><br><span class="line"># each row contains a digit at most once</span><br><span class="line">rows_c   = [ Distinct(X[i]) for i in range(9) ]</span><br><span class="line"></span><br><span class="line"># each column contains a digit at most once</span><br><span class="line">cols_c   = [ Distinct([ X[i][j] for i in range(9) ]) </span><br><span class="line">             for j in range(9) ]</span><br><span class="line"></span><br><span class="line"># each 3x3 square contains a digit at most once</span><br><span class="line">sq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j] </span><br><span class="line">                        for i in range(3) for j in range(3) ]) </span><br><span class="line">             for i0 in range(3) for j0 in range(3) ]</span><br><span class="line"></span><br><span class="line">sudoku_c = cells_c + rows_c + cols_c + sq_c</span><br><span class="line"></span><br><span class="line"># sudoku instance, we use &apos;0&apos; for empty cells</span><br><span class="line">instance = ((0,0,0,0,9,4,0,3,0),</span><br><span class="line">            (0,0,0,5,1,0,0,0,7),</span><br><span class="line">            (0,8,9,0,0,0,0,4,0),</span><br><span class="line">            (0,0,0,0,0,0,2,0,8),</span><br><span class="line">            (0,6,0,2,0,1,0,5,0),</span><br><span class="line">            (1,0,2,0,0,0,0,0,0),</span><br><span class="line">            (0,7,0,0,0,0,5,2,0),</span><br><span class="line">            (9,0,0,0,6,5,0,0,0),</span><br><span class="line">            (0,4,0,9,7,0,0,0,0))</span><br><span class="line"></span><br><span class="line">instance_c = [ If(instance[i][j] == 0, </span><br><span class="line">                  True, </span><br><span class="line">                  X[i][j] == instance[i][j]) </span><br><span class="line">               for i in range(9) for j in range(9) ]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(sudoku_c + instance_c)</span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    r = [ [ m.evaluate(X[i][j]) for j in range(9) ] </span><br><span class="line">          for i in range(9) ]</span><br><span class="line">    print_matrix(r)</span><br><span class="line">else:</span><br><span class="line">    print &quot;failed to solve&quot;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><p>八皇后问题：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击。即任意两个皇后都不能处于同一行、同一列或同一斜线上的摆法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We know each queen must be in a different row.</span></span><br><span class="line"><span class="comment"># So, we represent each queen by a single integer: the column position</span></span><br><span class="line">Q = [ Int(<span class="string">'Q_%i'</span> % (i + <span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Each queen is in a column &#123;1, ... 8 &#125;</span></span><br><span class="line">val_c = [ And(<span class="number">1</span> &lt;= Q[i], Q[i] &lt;= <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># At most one queen per column</span></span><br><span class="line">col_c = [ Distinct(Q) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Diagonal constraint</span></span><br><span class="line">diag_c = [ If(i == j, </span><br><span class="line">              <span class="keyword">True</span>, </span><br><span class="line">              And(Q[i] - Q[j] != i - j, Q[i] - Q[j] != j - i)) </span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(i) ]</span><br><span class="line"></span><br><span class="line">solve(val_c + col_c + diag_c)</span><br></pre></td></tr></table></figure>
<h3 id="应用：解决安装问题"><a href="#应用：解决安装问题" class="headerlink" title="应用：解决安装问题"></a>应用：解决安装问题</h3><p>常常用软件的安装问题通常是因为无法在系统上安装一组新包。Z3的这个应用适用于使用包管理器的系统。很多包都有其依赖。每个软件的发行版都包含一个<strong>meta-data</strong>文件用于指明该软件的依赖。<strong>meta-data</strong> 文件内包含依赖包的名字、版本等。更重要的是，它指明了软件的依赖包和有冲突的包。系统中不能安装那些有冲突的包。</p>
<p>Z3可以方便地解决安装问题。思路就是给每个包定义一个布尔变量。如果这个包必须被安装，则值为True。如果a包依赖于b，c和z，我们可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DependsOn(a, [b, c, z])</span><br></pre></td></tr></table></figure>
<p><strong>DependsOn</strong> 用于获取依赖包的条目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br></pre></td></tr></table></figure>
<p>因此，DependsOn(a, [b, c, z])返回下式的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">And(Implies(a, b), Implies(a, c), Implies(a, z))</span><br></pre></td></tr></table></figure>
<p>即，如果用户安装a包，则他们应该安装b，c和z。</p>
<p>如果d包与e包冲突，我们可以写为<strong>Conflict(d, e)</strong></p>
<p>其中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or(Not(p1), Not(p2))</span><br></pre></td></tr></table></figure>
<p>函数返回表达式 <strong>Or(Not(d), Not(e))</strong> 。</p>
<p>通过这两个函数，我们可以把该问题描述为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or(Not(p1), Not(p2))</span><br><span class="line"></span><br><span class="line">a, b, c, d, e, f, g, z = Bools(<span class="string">'a b c d e f g z'</span>)</span><br><span class="line"></span><br><span class="line">solve(DependsOn(a, [b, c, z]),</span><br><span class="line">      DependsOn(b, [d]),</span><br><span class="line">      DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">      Conflict(d, e),</span><br><span class="line">      a, z)</span><br></pre></td></tr></table></figure>
<p>注意这个例子隐含了约束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DependsOn(c, [Or(d, e), Or(f, g)])</span><br></pre></td></tr></table></figure>
<p>意思就是要安装c，必须安装d或e，和f或g。</p>
<p>现在，我们优化一下上面的代码。首先我们定义了<strong>DependsOn</strong> ，可以通过<strong>DependsOn(b, d)</strong> 调用。我们还定义了 <strong>install_check</strong> ，用于返回必须在系统上安装的包的列表，即计算的结果。函数<strong>Conflict</strong> 用于检测冲突，可以接收多个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_expr(deps):</span><br><span class="line">        <span class="keyword">return</span> Implies(pack, deps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(*packs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or([ Not(pack) <span class="keyword">for</span> pack <span class="keyword">in</span> packs ])</span><br><span class="line"></span><br><span class="line">a, b, c, d, e, f, g, z = Bools(<span class="string">'a b c d e f g z'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install_check</span><span class="params">(*problem)</span>:</span></span><br><span class="line">    s = Solver()</span><br><span class="line">    s.add(*problem)</span><br><span class="line">    <span class="keyword">if</span> s.check() == sat:</span><br><span class="line">        m = s.model()</span><br><span class="line">        r = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">if</span> is_true(m[x]):</span><br><span class="line">                <span class="comment"># x is a Z3 declaration</span></span><br><span class="line">                <span class="comment"># x() returns the Z3 expression</span></span><br><span class="line">                <span class="comment"># x.name() returns a string</span></span><br><span class="line">                r.append(x())</span><br><span class="line">        <span class="keyword">print</span> r</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"invalid installation profile"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Check 1"</span></span><br><span class="line">install_check(DependsOn(a, [b, c, z]),</span><br><span class="line">              DependsOn(b, d),</span><br><span class="line">              DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">              Conflict(d, e),</span><br><span class="line">              Conflict(d, g),</span><br><span class="line">              a, z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Check 2"</span></span><br><span class="line">install_check(DependsOn(a, [b, c, z]),</span><br><span class="line">              DependsOn(b, d),</span><br><span class="line">              DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">              Conflict(d, e),</span><br><span class="line">              Conflict(d, g),</span><br><span class="line">              a, z, g)</span><br></pre></td></tr></table></figure>
<h3 id="在本地使用Z3Py"><a href="#在本地使用Z3Py" class="headerlink" title="在本地使用Z3Py"></a>在本地使用Z3Py</h3><p>Z3Py是Z3发行版的一部分。在z3文件夹中<strong>python</strong> 子目录。为了在本地使用，必须在Python脚本中声明</p>
<p>from Z3 import *</p>
<p>z3 python的目录必须在环境变量<strong>PYTHONPATH</strong> 中。Z3Py会自动地搜索Z3运行库（z3.dll（WIN），libz3.so（Linux）或libz3.dylib（OSX））。你也可以使用下述命令手动初始化Z3Py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(<span class="string">"z3.dll"</span>)</span><br></pre></td></tr></table></figure>
<p>ref:</p>
<p>原文：<a href="http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm" target="_blank" rel="external">http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm</a></p>
<p>ScalaZ3：<a href="http://lara.epfl.ch/~psuter/ScalaZ3/" target="_blank" rel="external">http://lara.epfl.ch/~psuter/ScalaZ3/</a></p>
<p>SBV：<a href="http://hackage.haskell.org/package/sbv" target="_blank" rel="external">http://hackage.haskell.org/package/sbv</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2018/03/14/z3py/" data-id="cjer9tqqn00043ov065c9zply" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-README" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/14/README/" class="article-date">
  <time datetime="2017-11-14T14:12:38.000Z" itemprop="datePublished">2017-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/14/README/">README</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##HEY GUYS</p>
<p>##Welcome To My Blog</p>
<p>##I Share And Record My Notes Here</p>
<p>##You Can Download or Repaint Everything on This Blog</p>
<p>##And Please Annotate The Author When You Repaint My Blog</p>
<p>##Have Fun Guys</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2017/11/14/README/" data-id="cjer9tqq700003ov033kd1rrk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Init/">Init</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-emmm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/14/emmm/" class="article-date">
  <time datetime="2017-11-14T14:03:03.874Z" itemprop="datePublished">2017-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/14/emmm/">emmm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好像配友链配爆炸了呢。。。</p>
<p>编码炸了= =<br>辣鸡win<br>总不用utf-8</p>
<p>啊。。。今天不想配了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2017/11/14/emmm/" data-id="cjer9tqqn00053ov0el5vko2d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/14/hello-world/" class="article-date">
  <time datetime="2017-11-14T12:29:47.200Z" itemprop="datePublished">2017-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2017/11/14/hello-world/" data-id="cjer9tqqn00073ov0mwcxidlj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Init/">Init</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Init/" style="font-size: 10px;">Init</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/19/pthread/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/14/Bit_Twidding_Hack/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/14/emmmm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/14/z3py/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/14/README/">README</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://pupiles.com/'>Pupil</a></li>
        
          <li class='link'><a href='http://iruby.me'>Dimo</a></li>
        
          <li class='link'><a href='http://math1as.com/'>math1as</a></li>
        
          <li class='link'><a href='https://www.leavesongs.com/'>Ph1thon</a></li>
        
          <li class='link'><a href='http://www.cnblogs.com/iamstudy/'>l3m0n</a></li>
        
          <li class='link'><a href='http://120.25.96.6/wordpress/'>Chanson</a></li>
        
          <li class='link'><a href='http://www.k0rz3n.com/'>K0rz3n</a></li>
        
          <li class='link'><a href='https://notwo1f.github.io'>notwo1f</a></li>
        
          <li class='link'><a href='http://arch0n.sumblog.cn/'>Arch0n</a></li>
        
          <li class='link'><a href='http://feiyyx.cc/'>feiyyx</a></li>
        
          <li class='link'><a href='http://f1sh.site/'>f1sh</a></li>
        
          <li class='link'><a href='http://www.jestyf.cn'>xiaopu</a></li>
        
          <li class='link'><a href='https://www.short-circuits.org'>yeonji</a></li>
        
          <li class='link'><a href='https://bonus.zhishan-iot.ga'>zhishanIOT</a></li>
        
          <li class='link'><a href='https://blog.iret.xyz/'>Sliver</a></li>
        
      </ul>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>