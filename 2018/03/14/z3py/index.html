<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>nen9mA0&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Z3 API in Python原文地址：http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm Z3是微软研究院开发的一个高效的定理证明器。Z3可以被用于很多场景，例如：软件/硬件测试、约束求解、混合系统分析、安全、生物（药物设计）和几何问题。 这个教程展示了Z3Py的主要功能：python里的Z3 API。阅读此教">
<meta property="og:type" content="article">
<meta property="og:title" content="nen9mA0&#39;s Blog">
<meta property="og:url" content="https://nen9ma0.githubio.com/2018/03/14/z3py/index.html">
<meta property="og:site_name" content="nen9mA0&#39;s Blog">
<meta property="og:description" content="Z3 API in Python原文地址：http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm Z3是微软研究院开发的一个高效的定理证明器。Z3可以被用于很多场景，例如：软件/硬件测试、约束求解、混合系统分析、安全、生物（药物设计）和几何问题。 这个教程展示了Z3Py的主要功能：python里的Z3 API。阅读此教">
<meta property="og:updated_time" content="2018-03-12T10:53:25.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nen9mA0&#39;s Blog">
<meta name="twitter:description" content="Z3 API in Python原文地址：http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm Z3是微软研究院开发的一个高效的定理证明器。Z3可以被用于很多场景，例如：软件/硬件测试、约束求解、混合系统分析、安全、生物（药物设计）和几何问题。 这个教程展示了Z3Py的主要功能：python里的Z3 API。阅读此教">
  
    <link rel="alternate" href="/atom.xml" title="nen9mA0&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">nen9mA0&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nen9ma0.githubio.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-z3py" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/z3py/" class="article-date">
  <time datetime="2018-03-14T15:51:47.773Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Z3-API-in-Python"><a href="#Z3-API-in-Python" class="headerlink" title="Z3 API in Python"></a>Z3 API in Python</h1><p>原文地址：<a href="http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm" target="_blank" rel="external">http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm</a></p>
<p>Z3是微软研究院开发的一个高效的定理证明器。Z3可以被用于很多场景，例如：软件/硬件测试、约束求解、混合系统分析、安全、生物（药物设计）和几何问题。</p>
<p>这个教程展示了Z3Py的主要功能：python里的Z3 API。阅读此教程不需要Python基础。但学习Python很有用，同时也有很多的Python免费教程供我们学习（<a href="https://docs.python.org/3/tutorial/）" target="_blank" rel="external">https://docs.python.org/3/tutorial/）</a></p>
<p>Z3同样包含了C、.net和OCaml的API。Z3Py的源代码可以在Z3发行版中看到，你可以按照你的需求进行修改。源代码也展示了如何使用Z3 4.0的新功能。其他酷炫的Z3前端有ScalaZ3和SBV。</p>
<p>###入门</p>
<p>让我们从下面这个例子开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>函数 <strong>Int(‘x’)</strong> 定义了一个叫x的Z3整型变量， <strong>solve</strong> 函数求解这一约束系统。上面的例子用到了两个变量 <strong>x</strong> 和 <strong>y</strong> ，还有三个约束。Z3Py和Python一样使用 <strong>=</strong> 赋值。运算符 <strong>&lt;,&lt;=,&gt;,&gt;=,==,!=</strong> 用于比较。在上述例子中，表达式 <strong>x+2*y==7</strong> 是一个Z3约束。Z3可以求解并处理该等式。</p>
<p>下一个例子展示了如何用Z3公式/表达式 <strong>simplifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x &lt; y + x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>默认情况下，Z3Py（Web版）使用数学记号显示表达式。通常∧是逻辑与，∨是逻辑或。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_option(html_mode=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>使所有公式和表达式以Z3Py的记号显示。这也是Z3发行版的默认模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span></span><br><span class="line">set_option(html_mode=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span>py</span><br></pre></td></tr></table></figure>
<p>Z3提供拆分表达式的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num args: "</span>, n.num_args()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"children: "</span>, n.children()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1st child:"</span>, n.arg(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"2nd child:"</span>, n.arg(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"operator: "</span>, n.decl()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"op name:  "</span>, n.decl().name()</span><br></pre></td></tr></table></figure>
<p>Z3支持所有基础数学运算。Z3Py使用与Python相同的运算优先级。如Python中，**是乘幂。Z3可以求解非线性多项式约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> &gt; <span class="number">3</span>, x**<span class="number">3</span> + y &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Real(‘x’)</strong> 建立一个实变量x。Z3Py可以表示任意大的整数，有理数（如上面例子所示），代数数。代数数是指任何整系数多项式的复根。Z3内部精确的表示了每个数。无理数被显示为十进制使我们较容易读出结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">set_option(precision=<span class="number">30</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving, and displaying result with 30 decimal places"</span></span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>set_option</strong> 指令用于设置Z3环境。它被用于设置全局属性，如结果如何显示等。指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_option(precision=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>设置显示结果时显示的十进制数有几位。数值 <strong>1.2599210498?</strong> 中的 <strong>?</strong> 标记表示输出是被截断的。</p>
<p>下面的例子展示了一个常见的错误。表达式 <strong>3/2</strong> 是个Python数值但不是Z3中的有理数。这个例子也展示了创建有理数的不同方法。函数 <strong>Q(num,den)</strong> 创建一个Z3有理数，其中num是分子，den是分母。<strong>RealVal(1)</strong> 创建一个表示数值1的Z3实数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> RealVal(<span class="number">1</span>)/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> Q(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> x + Q(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="string">"1/3"</span></span><br><span class="line"><span class="keyword">print</span> x + <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>有理数也可以以十进制显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">set_option(rational_to_decimal=<span class="keyword">True</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">set_option(precision=<span class="number">30</span>)</span><br><span class="line">solve(<span class="number">3</span>*x == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一个约束系统不一定有解，在这种情况下，我们称系统无法满足（unsatisfiable）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(x &gt; <span class="number">4</span>, x &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>跟Python一样，单行注释使用 <strong>#</strong> ，但Z3Py不支持多行注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line">x = Real(<span class="string">'x'</span>) <span class="comment"># comment: creating x</span></span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + <span class="number">2</span>*x + <span class="number">2</span>  <span class="comment"># comment: printing polynomial</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>Z3支持的逻辑运算符：And,Or,Not,Implies(蕴含),If(if-then-else)。双蕴含用 <strong>==</strong> 表示。下面的例子展示了如何求解一个布尔约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line">r = Bool(<span class="string">'r'</span>)</span><br><span class="line">solve(Implies(p, q), r == Not(q), Or(Not(p), r))</span><br></pre></td></tr></table></figure>
<p>Python中的布尔常量 <strong>True</strong> 和 <strong>False</strong> 可以用于Z3表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line"><span class="keyword">print</span> And(p, q, <span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, q, <span class="keyword">True</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, <span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>
<p>下面的例子同时使用了多项式和布尔表达式约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(Or(x &lt; <span class="number">5</span>, x &gt; <span class="number">10</span>), Or(p, x**<span class="number">2</span> == <span class="number">2</span>), Not(p))</span><br></pre></td></tr></table></figure>
<h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>Z3提供了不同的求解器。上述例子中使用的命令 <strong>solve</strong> 调用了Z3求解器的API。这些调用可以在Z3目录下的 <strong>z3.py</strong> 中找到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">s.add(x &gt; <span class="number">10</span>, y == x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving constraints in the solver s ..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Create a new scope..."</span></span><br><span class="line">s.push()</span><br><span class="line">s.add(y &lt; <span class="number">11</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving updated set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Restoring state..."</span></span><br><span class="line">s.pop()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving restored set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure>
<p><strong>Solver()</strong> 命令定义了一个通用的求解器。所有约束式可以通过 <strong>add</strong> 方法添加。我们称约束式在求解器中 <strong>被声明</strong>。<strong>check()</strong> 方法求解所有已添加进求解器的约束式。如果可以求得解，该方法返回 <strong>sat</strong> 。如果不能求出解则返回 <strong>unsat</strong> 。也有可能出现声明的约束式不成立的情况，这时求解器返回 <strong>unknown</strong> 。</p>
<p>在一些应用下，我们希望求解一些相似的问题，这些问题有部分同样的约束式。我们可以使用 <strong>push</strong> 和 <strong>pop</strong> 命令。在Z3中，每个求解器维护一个保存声明的栈， <strong>push</strong> 命令保存当前栈空间大小，并创建一个空间，压入新的声明。 <strong>pop</strong> 命令删除上一个 <strong>push</strong> 命令压入的所有声明。<strong>check</strong> 方法计算求解器栈内的所有约束式。</p>
<p>下面的展示了一个Z3不能求解的例子。这种情况下求解器返回<strong>unknown</strong> 。注意Z3可以求解非线性多项式约束，但 2**x 不是多项式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure>
<p>下面的例子展示了如何将声明的约束式传入求解器，以及如何通过<strong>check</strong> 方法获取求解器状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, Or(x + y &gt; <span class="number">3</span>, x - y &lt; <span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"asserted constraints..."</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s.assertions():</span><br><span class="line">    <span class="keyword">print</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"statistics for the last check method..."</span></span><br><span class="line"><span class="keyword">print</span> s.statistics()</span><br><span class="line"><span class="comment"># Traversing statistics</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s.statistics():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s : %s"</span> % (k, v)</span><br></pre></td></tr></table></figure>
<p>当求解器找到解时， <strong>check</strong> 方法返回 <strong>sat</strong> 。我们称Z3求出满足约束式的解。我们称这个解为所声明的约束式的一个模型。一个模型是指一种解释，能使所有约束式满足。下面的例子展示了查看模型的基本方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = Reals(<span class="string">'x y z'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, x + y &gt; <span class="number">3</span>, z - x &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"x = %s"</span> % m[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，函数 <strong>Reals(‘x y z’)</strong> 创建了变量 x，y和z。这是下述写法的简写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">z = Real(<span class="string">'z'</span>)</span><br></pre></td></tr></table></figure>
<p>表达式 <strong>m[x]</strong> 模型m中的返回x的值。表达式 <strong>“%s = %s” % (d.name(), m[d])</strong> 返回一个字符串，其中第一个%s被d对象的name属性替换，第二个%s被<strong>m[d]</strong> 的值替换（注：Python语法）。Z3Py会自动地将Z3对象的值全部转换为文本。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>Z3支持实型和整型变量。在单个问题中两种变量可以混合使用。与大多数编程语言一样，当我们需要时，Z3Py会自动地将整型表达式强制转换为实型。下面的例子展示了各种声明整型和实型变量的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">a, b, c = Reals(<span class="string">'a b c'</span>)</span><br><span class="line">s, r = Ints(<span class="string">'s r'</span>)</span><br><span class="line"><span class="keyword">print</span> x + y + <span class="number">1</span> + (a + s)</span><br><span class="line"><span class="keyword">print</span> ToReal(y) + c</span><br></pre></td></tr></table></figure>
<p>函数<strong>ToReal</strong> 将一个整型表达式转换为实型。</p>
<p>Z3Py支持所有的基本的运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = Ints(<span class="string">'a b c'</span>)</span><br><span class="line">d, e = Reals(<span class="string">'d e'</span>)</span><br><span class="line">solve(a &gt; b + <span class="number">2</span>,</span><br><span class="line">      a == <span class="number">2</span>*c + <span class="number">10</span>,</span><br><span class="line">      c + b &lt;= <span class="number">1000</span>,</span><br><span class="line">      d &gt;= e)</span><br></pre></td></tr></table></figure>
<p>函数<strong>simplify</strong> 提供了一些方法，可以对Z3表达式进行简单变换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment"># Put expression in sum-of-monomials form</span></span><br><span class="line">t = simplify((x + y)**<span class="number">3</span>, som=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br><span class="line"><span class="comment"># Use power operator</span></span><br><span class="line">t = simplify(t, mul_to_power=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br></pre></td></tr></table></figure>
<p><strong>help_simplify</strong> 函数打印<strong>simplify</strong> 函数所有可用的参数。Z3Py允许用户以两种方式写入这些参数。Z3内部的参数名以<strong>:</strong> 开头并以<strong>-</strong> 隔开各个单词。这些参数可以被Z3Py使用。Z3Py也提供了一些符合Python变量命名规则的名字，在这里<strong>:</strong> 被移除，<strong>-</strong> 被<strong>_</strong> 取代。下面的例子展示了怎样使用以这两种方式调用函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment"># Using Z3 native option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, <span class="string">':arith-lhs'</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Using Z3Py option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, arith_lhs=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nAll available options:"</span></span><br><span class="line">help_simplify()</span><br></pre></td></tr></table></figure>
<p>Z3Py可以支持任意大的数字。下面的例子展示了使用大数，有理数和无理数进行基本运算。无理数中，Z3Py只支持代数数。代数数已经足够表示多项式约束的解了。Z3Py总是以十进制显示无理数，因为这方便阅读。可以使用 <strong>sexpr()</strong> 方法提取Z3内部的表达式，它能以S-表达式（s-expression）的形式显示Z3内部的数学表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line">solve(x + <span class="number">10000000000000000000000</span> == y, y &gt; <span class="number">20000000000000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)).sexpr()</span><br><span class="line"><span class="comment"># The sexpr() method is available for any Z3 expression</span></span><br><span class="line"><span class="keyword">print</span> (x + Sqrt(y) * <span class="number">2</span>).sexpr()</span><br></pre></td></tr></table></figure>
<h3 id="硬件相关的运算"><a href="#硬件相关的运算" class="headerlink" title="硬件相关的运算"></a>硬件相关的运算</h3><p>（注：此处为意译）</p>
<p>现代CPU和主流的编程语言使用基于固定大小的位向量的进行运算（注：如32位CPU采用基于位宽为32的数据进行运算）。在Z3Py中可以以位向量的方式进行这样的运算。位向量使我们可以看到有符号与无符号数的精确的补码表示。</p>
<p>下面的例子展示了如何创建位向量变量和常数。函数 <strong>BitVec(‘x’,16)</strong> 在Z3中创建了一个16位，名字为 <strong>x</strong> 的变量。为了方便使用，整数常量可以用于初始化位向量。函数 <strong>BitVecVal(10,32)</strong> 创建了一个32位的，值为10 的位向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = BitVec(<span class="string">'x'</span>, <span class="number">16</span>)</span><br><span class="line">y = BitVec(<span class="string">'y'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="number">2</span></span><br><span class="line"><span class="comment"># Internal representation</span></span><br><span class="line"><span class="keyword">print</span> (x + <span class="number">2</span>).sexpr()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -1 is equal to 65535 for 16-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(x + y - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating bit-vector constants</span></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">16</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br><span class="line"></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">32</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment"># -1 is not equal to 65535 for 32-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br></pre></td></tr></table></figure>
<p>其他编程语言，如C，C++，C#，Java的有符号与无符号数的各种运算对应的实际操作没有什么区别。但在Z3中，有符号数与无符号数使用不同的运算操作。 <strong>&lt;,&lt;=,&gt;,&gt;=,/,%,&gt;&gt;</strong> 运算对应有符号数，相对应的无符号数运算符为 <strong>ULT,ULE,UGT,UGE,UDiv,URem,LShR</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x + y == <span class="number">2</span>, x &gt; <span class="number">0</span>, y &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bit-wise operators</span></span><br><span class="line"><span class="comment"># &amp; bit-wise and</span></span><br><span class="line"><span class="comment"># | bit-wise or</span></span><br><span class="line"><span class="comment"># ~ bit-wise not</span></span><br><span class="line">solve(x &amp; y == ~y)</span><br><span class="line"></span><br><span class="line">solve(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># using unsigned version of &lt; </span></span><br><span class="line">solve(ULT(x, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>运算符 <strong>&gt;&gt;</strong> 是算术右移， <strong>&lt;&lt;</strong> 是算术左移。逻辑右移是 <strong>LShR</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x &gt;&gt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>不像其他编程语言，函数可以抛出异常或者无法返回。Z3的函数是完全定义的，即，函数是被所有输入的值所定义的，其中输入的值可以是一个函数，如划分函数。Z3是基于一阶逻辑的。</p>
<p>当我们给出约束式，如 <strong>x+y&gt;3</strong> 时，我们称 <strong>x</strong> 和 <strong>y</strong> 是变量。在很多书中，<strong>x</strong> 和 <strong>y</strong> 称为未定义常量。即，它们可以被赋值为任何满足约束式 <strong>x+y&gt;3</strong> 的值。</p>
<p>准确地说，一阶逻辑中的函数和符号常量是未定义的。这与很多其他理论中的函数相反，如算法中的函数 <strong>+</strong> 拥有标准的定义（将两数相加）。未定义函数和常量可以提供最大限度的灵活性：只要符合约束式，允许对函数和常量做出任何定义。（注：此段感觉翻译有误）</p>
<p>为了解释未定义的函数和常量的含义，我们定义了两个整数常量x和y。然后声明一个未进行定义的函数，这个函数有一个整型参数且返回值为一个整型。这个例子展示了我们可以使嵌套调用两次的f(x)等于x，即f(f(x)) == x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">f = Function(<span class="string">'f'</span>, IntSort(), IntSort())</span><br><span class="line">solve(f(f(x)) == x, f(x) == y, x != y)</span><br></pre></td></tr></table></figure>
<p>返回的结果为：f函数的定义是：f(0)=1 f(1)=0 f(a)=1 当a≠0,1</p>
<p>（注：这段因为涉及到一阶逻辑的知识翻了好久还是一头雾水，不过看了下代码，这段大概的意思应该就是，Z3的输入可以是一个未定义具体内容的函数，它可以通过与该函数相关的一些约束式来求出符合要求的函数模型）</p>
<p>在Z3中，我们也可以计算在一系列约束式下的一些表达式的值。下面的例子说明了如何使用 <strong>evaluate</strong> 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">f = Function(<span class="string">'f'</span>, IntSort(), IntSort())</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(f(f(x)) == x, f(x) == y, x != y)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"f(f(x)) ="</span>, m.evaluate(f(f(x)))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"f(x)    ="</span>, m.evaluate(f(x))</span><br></pre></td></tr></table></figure>
<p>###可满足性和有效性</p>
<p>当一个约束式/公式 F的值在任何有效取值下始终为真，称该公式为普遍有效公式（即恒真公式）。当约束式在一些取值下为真则称公式为可满足的。验证有效性时，即需要找出命题为永真的证明。验证可满足性则是求出一个满足式子的集合。考虑一个包含 <strong>a</strong> 和 <strong>b</strong> 的公式 <strong>F</strong> 。<strong>F</strong> 是否普遍有效即是否在 <strong>a</strong> 和 <strong>b</strong> 的所有取值下<strong>F</strong> 都为真。如果<strong>F</strong> 是有效的，则<strong>Not(F)</strong> 为永假的，即<strong>Not(F)</strong> 在任何取值下都不为真，即，<strong>Not(F)</strong> 是不可满足的。所以公式<strong>F</strong> 在<strong>Not(F)</strong> 不可满足时为永真的。 同样，当且仅当 <strong>Not(F)</strong> 不为永真时，<strong>F</strong> 是可满足的。下面的例子证明了<strong>德摩根定理</strong> 。</p>
<p>下面的例子定义了一个Z3Py函数，它接收了一个公式作为参数。这个函数创建一个Z3求解器，并添加了传入参数的公式的<strong>非</strong> ，检查这个公式的非是否是不可满足的。下述的函数是Z3Py的命令<strong>prove</strong> 的简化版。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p, q = Bools(<span class="string">'p q'</span>)</span><br><span class="line">demorgan = And(p, q) == Not(Or(Not(p), Not(q)))</span><br><span class="line"><span class="keyword">print</span> demorgan</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prove</span><span class="params">(f)</span>:</span></span><br><span class="line">    s = Solver()</span><br><span class="line">    s.add(Not(f))</span><br><span class="line">    <span class="keyword">if</span> s.check() == unsat:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"proved"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"failed to prove"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Proving demorgan..."</span></span><br><span class="line">prove(demorgan)</span><br></pre></td></tr></table></figure>
<h3 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h3><p>Python支持列表解析式。列表解析式为创建列表提供了一个简便的方法。它们可以用于创建Z3表达式。下面的例子展示了如何在Z3Py中使用过列表解析式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> Create list [<span class="number">1</span>, ..., <span class="number">5</span>] </span><br><span class="line"><span class="keyword">print</span> [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create two lists containg 5 integer variables</span></span><br><span class="line">X = [ Int(<span class="string">'x%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line">Y = [ Int(<span class="string">'y%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a list containing X[i]+Y[i]</span></span><br><span class="line">X_plus_Y = [ X[i] + Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_plus_Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a list containing X[i] &gt; Y[i]</span></span><br><span class="line">X_gt_Y = [ X[i] &gt; Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_gt_Y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> And(X_gt_Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a 3x3 "matrix" (list of lists) of integer variables</span></span><br><span class="line">X = [ [ Int(<span class="string">"x_%s_%s"</span> % (i+<span class="number">1</span>, j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>) ] </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>) ]</span><br><span class="line">pp(X)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，表达式 <strong>“x%s” %i</strong> 返回一个由i的值替换%s的字符串。</p>
<p>命令<strong>pp</strong> 与<strong>print</strong> 类似，但它使用Z3用于格式化元组和列表的格式化字符串，而不是Python的。</p>
<p>Z3Py也提供创建布尔、整型和实型向量的函数，这些函数可以在列表解析式中被执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = IntVector(<span class="string">'x'</span>, <span class="number">5</span>)</span><br><span class="line">Y = RealVector(<span class="string">'y'</span>, <span class="number">5</span>)</span><br><span class="line">P = BoolVector(<span class="string">'p'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line"><span class="keyword">print</span> Y</span><br><span class="line"><span class="keyword">print</span> P</span><br><span class="line"><span class="keyword">print</span> [ y**<span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> Y ]</span><br><span class="line"><span class="keyword">print</span> Sum([ y**<span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> Y ])</span><br></pre></td></tr></table></figure>
<p>（注：下面内容为Z3在一些领域应用的示例）</p>
<p>###运动方程</p>
<p>在高中中，我们学习过运动方程。这些等式描述了位移、时间、加速度、初速度和末速度的关系。在Z3Py中可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span></span><br><span class="line">v_f == v_i + a*t</span><br></pre></td></tr></table></figure>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>Ima Hurryin以30m/s的速度靠近红绿灯。此时灯变黄，Ima踩下刹车。如果Ima的加速度为-8.00m/s^2，请计算车辆在减速过程中的位移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d, a, t, v_i, v_f = Reals(<span class="string">'d a t v__i v__f'</span>)</span><br><span class="line"></span><br><span class="line">equations = [</span><br><span class="line">   d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span>,</span><br><span class="line">   v_f == v_i + a*t,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Kinematic equations:"</span></span><br><span class="line"><span class="keyword">print</span> equations</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given v_i, v_f and a, find d</span></span><br><span class="line">problem = [</span><br><span class="line">    v_i == <span class="number">30</span>,</span><br><span class="line">    v_f == <span class="number">0</span>,</span><br><span class="line">    a   == <span class="number">-8</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Problem:"</span></span><br><span class="line"><span class="keyword">print</span> problem </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solution:"</span></span><br><span class="line">solve(equations + problem)</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>Ben Rushin在等红绿灯。当灯变绿时，Ben以6.00m/s^2的加速度加速4.10秒。请计算这段时间Ben的位移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d, a, t, v_i, v_f = Reals(<span class="string">'d a t v__i v__f'</span>)</span><br><span class="line"></span><br><span class="line">equations = [</span><br><span class="line">   d == v_i * t + (a*t**<span class="number">2</span>)/<span class="number">2</span>,</span><br><span class="line">   v_f == v_i + a*t,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given v_i, t and a, find d</span></span><br><span class="line">problem = [</span><br><span class="line">    v_i == <span class="number">0</span>,</span><br><span class="line">    t   == <span class="number">4.10</span>,</span><br><span class="line">    a   == <span class="number">6</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">solve(equations + problem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display rationals in decimal notation</span></span><br><span class="line">set_option(rational_to_decimal=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">solve(equations + problem)</span><br></pre></td></tr></table></figure>
<p>###位运算技巧</p>
<p>一些底层的位运算技巧在C程序员中很流行。我们试着用Z3实现其中一些技巧。</p>
<h4 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h4><p>这个技巧常用于C程序（包括Z3源码）中测试一个整数是否是2的幂。我们可以用Z3证明这个算法的正确性。此处即证明 <strong>x != 0 &amp;&amp; !(x &amp; (x - 1))</strong> 为真，当且仅当<strong>x</strong> 为2的幂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x      = BitVec(<span class="string">'x'</span>, <span class="number">32</span>)</span><br><span class="line">powers = [ <span class="number">2</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>) ]</span><br><span class="line">fast   = And(x != <span class="number">0</span>, x &amp; (x - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">slow   = Or([ x == p <span class="keyword">for</span> p <span class="keyword">in</span> powers ])</span><br><span class="line"><span class="keyword">print</span> fast</span><br><span class="line">prove(fast == slow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"trying to prove buggy version..."</span></span><br><span class="line">fast   = x &amp; (x - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">prove(fast == slow)</span><br></pre></td></tr></table></figure>
<p>####相反数</p>
<p>下面的技巧用于测试两个数是否互为相反数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x      = BitVec(<span class="string">'x'</span>, <span class="number">32</span>)</span><br><span class="line">y      = BitVec(<span class="string">'y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Claim: (x ^ y) &lt; 0 iff x and y have opposite signs</span></span><br><span class="line">trick  = (x ^ y) &lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Naive way to check if x and y have opposite signs</span></span><br><span class="line">opposite = Or(And(x &lt; <span class="number">0</span>, y &gt;= <span class="number">0</span>),</span><br><span class="line">              And(x &gt;= <span class="number">0</span>, y &lt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">prove(trick == opposite)</span><br></pre></td></tr></table></figure>
<h3 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h3><h4 id="猫狗和老鼠"><a href="#猫狗和老鼠" class="headerlink" title="猫狗和老鼠"></a>猫狗和老鼠</h4><p>我们花费100美元要购买100只动物。每只狗15美元，猫1美元，老鼠25美分。且必须每种至少买一只，求购买方案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create 3 integer variables</span></span><br><span class="line">dog, cat, mouse = Ints(<span class="string">'dog cat mouse'</span>)</span><br><span class="line">solve(dog &gt;= <span class="number">1</span>,   <span class="comment"># at least one dog</span></span><br><span class="line">      cat &gt;= <span class="number">1</span>,   <span class="comment"># at least one cat</span></span><br><span class="line">      mouse &gt;= <span class="number">1</span>, <span class="comment"># at least one mouse</span></span><br><span class="line">      <span class="comment"># we want to buy 100 animals</span></span><br><span class="line">      dog + cat + mouse == <span class="number">100</span>,  </span><br><span class="line">      <span class="comment"># We have 100 dollars (10000 cents):</span></span><br><span class="line">      <span class="comment">#   dogs cost 15 dollars (1500 cents), </span></span><br><span class="line">      <span class="comment">#   cats cost 1 dollar (100 cents), and </span></span><br><span class="line">      <span class="comment">#   mice cost 25 cents </span></span><br><span class="line">      <span class="number">1500</span> * dog + <span class="number">100</span> * cat + <span class="number">25</span> * mouse == <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h4><p>下面的例子展示了如何用Z3求解数独问题。其中<strong>instance</strong> 定义了数独矩阵。这个例子大量使用了Python中的列表解析式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 9x9 matrix of integer variables</span><br><span class="line">X = [ [ Int(&quot;x_%s_%s&quot; % (i+1, j+1)) for j in range(9) ] </span><br><span class="line">      for i in range(9) ]</span><br><span class="line"></span><br><span class="line"># each cell contains a value in &#123;1, ..., 9&#125;</span><br><span class="line">cells_c  = [ And(1 &lt;= X[i][j], X[i][j] &lt;= 9) </span><br><span class="line">             for i in range(9) for j in range(9) ]</span><br><span class="line"></span><br><span class="line"># each row contains a digit at most once</span><br><span class="line">rows_c   = [ Distinct(X[i]) for i in range(9) ]</span><br><span class="line"></span><br><span class="line"># each column contains a digit at most once</span><br><span class="line">cols_c   = [ Distinct([ X[i][j] for i in range(9) ]) </span><br><span class="line">             for j in range(9) ]</span><br><span class="line"></span><br><span class="line"># each 3x3 square contains a digit at most once</span><br><span class="line">sq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j] </span><br><span class="line">                        for i in range(3) for j in range(3) ]) </span><br><span class="line">             for i0 in range(3) for j0 in range(3) ]</span><br><span class="line"></span><br><span class="line">sudoku_c = cells_c + rows_c + cols_c + sq_c</span><br><span class="line"></span><br><span class="line"># sudoku instance, we use &apos;0&apos; for empty cells</span><br><span class="line">instance = ((0,0,0,0,9,4,0,3,0),</span><br><span class="line">            (0,0,0,5,1,0,0,0,7),</span><br><span class="line">            (0,8,9,0,0,0,0,4,0),</span><br><span class="line">            (0,0,0,0,0,0,2,0,8),</span><br><span class="line">            (0,6,0,2,0,1,0,5,0),</span><br><span class="line">            (1,0,2,0,0,0,0,0,0),</span><br><span class="line">            (0,7,0,0,0,0,5,2,0),</span><br><span class="line">            (9,0,0,0,6,5,0,0,0),</span><br><span class="line">            (0,4,0,9,7,0,0,0,0))</span><br><span class="line"></span><br><span class="line">instance_c = [ If(instance[i][j] == 0, </span><br><span class="line">                  True, </span><br><span class="line">                  X[i][j] == instance[i][j]) </span><br><span class="line">               for i in range(9) for j in range(9) ]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(sudoku_c + instance_c)</span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    r = [ [ m.evaluate(X[i][j]) for j in range(9) ] </span><br><span class="line">          for i in range(9) ]</span><br><span class="line">    print_matrix(r)</span><br><span class="line">else:</span><br><span class="line">    print &quot;failed to solve&quot;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><p>八皇后问题：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击。即任意两个皇后都不能处于同一行、同一列或同一斜线上的摆法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We know each queen must be in a different row.</span></span><br><span class="line"><span class="comment"># So, we represent each queen by a single integer: the column position</span></span><br><span class="line">Q = [ Int(<span class="string">'Q_%i'</span> % (i + <span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Each queen is in a column &#123;1, ... 8 &#125;</span></span><br><span class="line">val_c = [ And(<span class="number">1</span> &lt;= Q[i], Q[i] &lt;= <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># At most one queen per column</span></span><br><span class="line">col_c = [ Distinct(Q) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Diagonal constraint</span></span><br><span class="line">diag_c = [ If(i == j, </span><br><span class="line">              <span class="keyword">True</span>, </span><br><span class="line">              And(Q[i] - Q[j] != i - j, Q[i] - Q[j] != j - i)) </span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(i) ]</span><br><span class="line"></span><br><span class="line">solve(val_c + col_c + diag_c)</span><br></pre></td></tr></table></figure>
<h3 id="应用：解决安装问题"><a href="#应用：解决安装问题" class="headerlink" title="应用：解决安装问题"></a>应用：解决安装问题</h3><p>常常用软件的安装问题通常是因为无法在系统上安装一组新包。Z3的这个应用适用于使用包管理器的系统。很多包都有其依赖。每个软件的发行版都包含一个<strong>meta-data</strong>文件用于指明该软件的依赖。<strong>meta-data</strong> 文件内包含依赖包的名字、版本等。更重要的是，它指明了软件的依赖包和有冲突的包。系统中不能安装那些有冲突的包。</p>
<p>Z3可以方便地解决安装问题。思路就是给每个包定义一个布尔变量。如果这个包必须被安装，则值为True。如果a包依赖于b，c和z，我们可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DependsOn(a, [b, c, z])</span><br></pre></td></tr></table></figure>
<p><strong>DependsOn</strong> 用于获取依赖包的条目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br></pre></td></tr></table></figure>
<p>因此，DependsOn(a, [b, c, z])返回下式的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">And(Implies(a, b), Implies(a, c), Implies(a, z))</span><br></pre></td></tr></table></figure>
<p>即，如果用户安装a包，则他们应该安装b，c和z。</p>
<p>如果d包与e包冲突，我们可以写为<strong>Conflict(d, e)</strong></p>
<p>其中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or(Not(p1), Not(p2))</span><br></pre></td></tr></table></figure>
<p>函数返回表达式 <strong>Or(Not(d), Not(e))</strong> 。</p>
<p>通过这两个函数，我们可以把该问题描述为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or(Not(p1), Not(p2))</span><br><span class="line"></span><br><span class="line">a, b, c, d, e, f, g, z = Bools(<span class="string">'a b c d e f g z'</span>)</span><br><span class="line"></span><br><span class="line">solve(DependsOn(a, [b, c, z]),</span><br><span class="line">      DependsOn(b, [d]),</span><br><span class="line">      DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">      Conflict(d, e),</span><br><span class="line">      a, z)</span><br></pre></td></tr></table></figure>
<p>注意这个例子隐含了约束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DependsOn(c, [Or(d, e), Or(f, g)])</span><br></pre></td></tr></table></figure>
<p>意思就是要安装c，必须安装d或e，和f或g。</p>
<p>现在，我们优化一下上面的代码。首先我们定义了<strong>DependsOn</strong> ，可以通过<strong>DependsOn(b, d)</strong> 调用。我们还定义了 <strong>install_check</strong> ，用于返回必须在系统上安装的包的列表，即计算的结果。函数<strong>Conflict</strong> 用于检测冲突，可以接收多个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DependsOn</span><span class="params">(pack, deps)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_expr(deps):</span><br><span class="line">        <span class="keyword">return</span> Implies(pack, deps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> And([ Implies(pack, dep) <span class="keyword">for</span> dep <span class="keyword">in</span> deps ])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Conflict</span><span class="params">(*packs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Or([ Not(pack) <span class="keyword">for</span> pack <span class="keyword">in</span> packs ])</span><br><span class="line"></span><br><span class="line">a, b, c, d, e, f, g, z = Bools(<span class="string">'a b c d e f g z'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install_check</span><span class="params">(*problem)</span>:</span></span><br><span class="line">    s = Solver()</span><br><span class="line">    s.add(*problem)</span><br><span class="line">    <span class="keyword">if</span> s.check() == sat:</span><br><span class="line">        m = s.model()</span><br><span class="line">        r = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">if</span> is_true(m[x]):</span><br><span class="line">                <span class="comment"># x is a Z3 declaration</span></span><br><span class="line">                <span class="comment"># x() returns the Z3 expression</span></span><br><span class="line">                <span class="comment"># x.name() returns a string</span></span><br><span class="line">                r.append(x())</span><br><span class="line">        <span class="keyword">print</span> r</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"invalid installation profile"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Check 1"</span></span><br><span class="line">install_check(DependsOn(a, [b, c, z]),</span><br><span class="line">              DependsOn(b, d),</span><br><span class="line">              DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">              Conflict(d, e),</span><br><span class="line">              Conflict(d, g),</span><br><span class="line">              a, z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Check 2"</span></span><br><span class="line">install_check(DependsOn(a, [b, c, z]),</span><br><span class="line">              DependsOn(b, d),</span><br><span class="line">              DependsOn(c, [Or(d, e), Or(f, g)]),</span><br><span class="line">              Conflict(d, e),</span><br><span class="line">              Conflict(d, g),</span><br><span class="line">              a, z, g)</span><br></pre></td></tr></table></figure>
<h3 id="在本地使用Z3Py"><a href="#在本地使用Z3Py" class="headerlink" title="在本地使用Z3Py"></a>在本地使用Z3Py</h3><p>Z3Py是Z3发行版的一部分。在z3文件夹中<strong>python</strong> 子目录。为了在本地使用，必须在Python脚本中声明</p>
<p>from Z3 import *</p>
<p>z3 python的目录必须在环境变量<strong>PYTHONPATH</strong> 中。Z3Py会自动地搜索Z3运行库（z3.dll（WIN），libz3.so（Linux）或libz3.dylib（OSX））。你也可以使用下述命令手动初始化Z3Py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(<span class="string">"z3.dll"</span>)</span><br></pre></td></tr></table></figure>
<p>ref:</p>
<p>原文：<a href="http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm" target="_blank" rel="external">http://www.cs.tau.ac.il/~msagiv/courses/asv/z3py/guide-examples.htm</a></p>
<p>ScalaZ3：<a href="http://lara.epfl.ch/~psuter/ScalaZ3/" target="_blank" rel="external">http://lara.epfl.ch/~psuter/ScalaZ3/</a></p>
<p>SBV：<a href="http://hackage.haskell.org/package/sbv" target="_blank" rel="external">http://hackage.haskell.org/package/sbv</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nen9ma0.githubio.com/2018/03/14/z3py/" data-id="cjer9tqqn00043ov065c9zply" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/14/emmmm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/11/14/README/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">README</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Init/">Init</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Init/" style="font-size: 10px;">Init</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/14/Bit_Twidding_Hack/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/14/emmmm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/14/z3py/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/14/README/">README</a>
          </li>
        
          <li>
            <a href="/2017/11/14/emmm/">emmm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://pupiles.com/'>Pupil</a></li>
        
          <li class='link'><a href='http://iruby.me'>Dimo</a></li>
        
          <li class='link'><a href='http://math1as.com/'>math1as</a></li>
        
          <li class='link'><a href='https://www.leavesongs.com/'>Ph1thon</a></li>
        
          <li class='link'><a href='http://www.cnblogs.com/iamstudy/'>l3m0n</a></li>
        
          <li class='link'><a href='http://120.25.96.6/wordpress/'>Chanson</a></li>
        
          <li class='link'><a href='http://www.k0rz3n.com/'>K0rz3n</a></li>
        
          <li class='link'><a href='https://notwo1f.github.io'>notwo1f</a></li>
        
          <li class='link'><a href='http://arch0n.sumblog.cn/'>Arch0n</a></li>
        
          <li class='link'><a href='http://feiyyx.cc/'>feiyyx</a></li>
        
          <li class='link'><a href='http://f1sh.site/'>f1sh</a></li>
        
          <li class='link'><a href='http://www.jestyf.cn'>xiaopu</a></li>
        
          <li class='link'><a href='https://www.short-circuits.org'>yeonji</a></li>
        
          <li class='link'><a href='https://bonus.zhishan-iot.ga'>zhishanIOT</a></li>
        
      </ul>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>